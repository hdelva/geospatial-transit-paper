<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta charset="utf-8" />
  <title>Geospatial fragmentation of open transit data</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
       <script src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js" integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ" crossorigin="anonymous"></script>
         <link rel="stylesheet" media="screen" href="styles/screen.css" />
  <link rel="stylesheet" media="print"  href="styles/print.css" />  <meta name="citation_title" content="Geospatial fragmentation of open transit data">
  <meta name="citation_author" content="John Doe" />
  
  <meta name="citation_publication_date" content="2020/01/16" />
</head>

<body prefix="rdf: http://www.w3.org/1999/02/22-rdf-syntax-ns# rdfs: http://www.w3.org/2000/01/rdf-schema# owl: http://www.w3.org/2002/07/owl# xsd: http://www.w3.org/2001/XMLSchema# dcterms: http://purl.org/dc/terms/ dctypes: http://purl.org/dc/dcmitype/ foaf: http://xmlns.com/foaf/0.1/ v: http://www.w3.org/2006/vcard/ns# pimspace: http://www.w3.org/ns/pim/space# cc: https://creativecommons.org/ns# skos: http://www.w3.org/2004/02/skos/core# prov: http://www.w3.org/ns/prov# qb: http://purl.org/linked-data/cube# schema: http://schema.org/ void: http://rdfs.org/ns/void# rsa: http://www.w3.org/ns/auth/rsa# cert: http://www.w3.org/ns/auth/cert# cal: http://www.w3.org/2002/12/cal/ical# wgs: http://www.w3.org/2003/01/geo/wgs84_pos# org: http://www.w3.org/ns/org# biblio: http://purl.org/net/biblio# bibo: http://purl.org/ontology/bibo/ book: http://purl.org/NET/book/vocab# ov: http://open.vocab.org/terms/ sioc: http://rdfs.org/sioc/ns# doap: http://usefulinc.com/ns/doap# dbr: http://dbpedia.org/resource/ dbp: http://dbpedia.org/property/ sio: http://semanticscience.org/resource/ opmw: http://www.opmw.org/ontology/ deo: http://purl.org/spar/deo/ doco: http://purl.org/spar/doco/ cito: http://purl.org/spar/cito/ fabio: http://purl.org/spar/fabio/ oa: http://www.w3.org/ns/oa# as: https://www.w3.org/ns/activitystreams# ldp: http://www.w3.org/ns/ldp# solid: http://www.w3.org/ns/solid/terms# acl: http://www.w3.org/ns/auth/acl# dio: https://w3id.org/dio# as: https://www.w3.org/ns/activitystreams# oa: http://www.w3.org/ns/oa# ldp: http://www.w3.org/ns/ldp#" typeof="schema:CreativeWork sioc:Post prov:Entity">
  <header>
  <h1 id="geospatial-fragmentation-of-open-transit-data">Geospatial fragmentation of open transit data</h1>

  <!--- <a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="http://www.example.org/" typeof="foaf:Person schema:Person" resource="http://www.example.org/#me">John Doe</a> 

{:#affiliations}
- {:#myaffiliation} Awesome Inc.

-->

  <section id="abstract" inlist="" rel="schema:hasPart" resource="#abstract">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Abstract</h2>
      <!-- Context - bigger picture     -->
      <p>The more unique your mobility needs are, the less likely you are to find an existing data service that suits your needs. Therein lies the beauty of publishing the raw data; data owners don’t have to anticipate everyone’s needs if third parties can fill in the gaps.
<!-- Need - gap we try to solve   -->
Public transit operators often publish their data as a large data dump under the assumption that data consumers want to process the entire dataset anyway. Unfortunately, developers with limited computational resources can have trouble ingesting all this data. Linked Connections is an alternative publishing scheme that fragments the data by the connections’ departure times. This enables data consumers to be more selective in the data they choose to process. This is already a good improvement over monolithic data dumps, but each fragment still contains data from the entire operator’s service area.
<!-- Task - what we did           -->
We build upon the idea of Linked Connections by fragmenting geospatially as well as by departure time. Ideally, our publishing scheme must work in the case  where the data publisher is not the data owner. This means that the fragmentation method should be robust to changes in the original data, such as the deletion or the addition of stops. Contrary to the conventional approach of generating discrete sets of stops, we propose generating geospatial partitions instead. These partitions are published alongside the transit data itself, allowing data consumers to infer which fragments contain which data. 
<!-- Object       -->
In this paper we explore conventional clustering methods such as k-Means and METIS, alongside two simple methods of our own that are custom-tailored to public transit data. We compare the effectiveness of each for the use case of client-side route planning.
<!-- Findings     -->
Our results show that the number of generated partitions greatly affects the performance of route planning. Even with only 4 partitions queries get answered 2.2 times faster while also requiring 2.6 times less data, and 16 partitions already yield 4.4 times faster queries and 7.2 times less required data. Interestingly enough the choice of fragmentation strategy has less impact; a simple clustering method such as k-Means results in 5% faster queries than a complex method such as METIS.
<!-- Conclusion   -->
These results show that data publishers don’t have to train the perfect clustering model – even a simple approach is effective. 
<!-- Perspectives -->
Consequently, this increases the likelihood that such a publishing scheme may be adopted.</p>
    </div>
</section>

</header>

<main>
  <!-- Add sections by specifying their file name, excluding the '.md' suffix. -->
  <section id="introduction" inlist="" rel="schema:hasPart" resource="#introduction">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Introduction</h2>

      <p>The <a href="https://opendefinition.org/">Open Definition</a> defines open data as data that can be: “… freely used, modified, and shared by anyone for any purpose”. This may seem utopian, but these principles are being adopted all over the world. The OECD has documented the positive impact of <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/https://doi.org/https://doi.org/10.1787/5k46bj4f03s7-en"><a href="https://www.oecd-ilibrary.org/content/paper/5k46bj4f03s7-en">Open Government Data</a></span> <span class="references">[<a href="#ref-1">1</a>]</span>, and similar ideas have surfaced in academics with the FAIR Data Principles <span class="references">[<a href="#ref-2">2</a>]</span> where a common guideline is to make data “As open as possible as possible, as closed as necessary” <span class="references">[<a href="#ref-3">3</a>]</span>.</p>

      <p>Consider the case of someone who is looking to buy a house, and the quality of service of wheelchair accessible public transit is important to them. A real estate site could include this information in their item listings, but only if they can find and access relevant datasets. Luckily, many public transit operators publish their timetables as open data. This is often done using de facto standards such as General Transit Feed Specification <a href="https://developers.google.com/transit/gtfs">(GTFS)</a> or using official standards such as Network Timetable Exchange <a href="http://netex-cen.eu/">(NeTEx)</a>. However, these data standards result in large data dumps: the combined GTFS feed of the public transit companies that operate in the Brussels area (SNCB, STIB, De Lijn, and Tec) is already over 1 GB of uncompressed data. A hobbyist developer that wants use a Raspberry Pi to show a dashboard of bus passages near them can run into issues ingesting and processing all this data.</p>

      <p>Another use case for open transit data is route planning. The ideal route is subjective; a reasonable walking distance differs from person to person, and even depends on a person’s mood. Contemporary route planning services preprocess data to provide better query time performance <span class="references">[<a href="#ref-4">4</a>, <a href="#ref-5">5</a>, <a href="#ref-6">6</a>]</span>, but this preprocessing also restricts the types of queries that can be answered. For example, an algorithm that reuses precomputed shortest paths between stops will not be able to give you the most scenic path – unless those are precomputed as well. But what if you could use your own device to calculate your own personalized routes? You could tweak journeys until you find exactly what you are looking for, without putting an unreasonable strain on a route planning service. This approach obviously comes with its own challenges, and ingesting data is again one of them. Downloading the entire dataset on your phone to plan a route from one adjacent city to another is too slow to be practical.</p>

      <p>These examples show that the way data is published can restrict how the data can be used. What may be feasible for a corporation may not be feasible for a regular person, even though the idea of open data is to make the data usable by everyone.</p>

    </div>
</section>

  <section id="related-work" inlist="" rel="schema:hasPart" resource="#related-work">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Related work</h2>

      <h3 id="linked-data-fragments">Linked Data Fragments</h3>

      <p>Tim Berners-Lee outlined four principles of Linked Data <span class="references">[<a href="#ref-7">7</a>]</span>: 1) use URIs as names for things, 2) use HTTP URIs so that people can look up those names, 3) when someone looks up a URI, provide useful information using standards such as RDF, and 4) include links to other URIs so that they can discover more things. In the conceptual framework of Linked Data Fragments <span class="references">[<a href="#ref-8">8</a>]</span>, this is just one interface to access Linked Data. You could also publish the data as one large data dump, or provide a querying API on top of the data. What all these interfaces have in common is that they expose a <em>fragment</em> of the entire dataset, so they can all be considered Linked Data Fragments. Data dumps and query APIs are the two extremes on the Linked Data Fragments axis <span class="references">[<a href="#ref-8">8</a>]</span>. This axis serves illustrates the trade-offs between different methods of publishing Linked Data on the Web. Data dumps put the data processing burden on the client’s side, but allow the most flexibility for clients. Query APIs on the other hand put the processing burden on the server side but always restrict, in some way, the way the data can be used.</p>

      <h3 id="mobility-data">Mobility Data</h3>

      <p>The General Transit Feed Specification (GTFS) is, at the time of writing, the de facto standard for publishing public transit schedules. A single feed is a combination of 6 to 13 CSV files, compressed into a single ZIP archive. Its core data elements are stops, routes, trips, and stop times. Stops are places where vehicles pick up or drop off riders, routes are two or more stops that form a public transit line, trips correspond to a physical vehicle that follows a route during a specific time period, and stop times indicate when a trip passes by a stop. This data is not only useful for route planning applications, other applications include embedding timetables in mobile applications, data visualization; accessibility analysis, and planning analysis <span class="references">[<a href="#ref-9">9</a>]</span>.</p>

      <p>The Linked Connections specification <span class="references">[<a href="#ref-10">10</a>]</span> defines a way to publish transit data that falls somewhere in the middle of the Linked Data Fragments axis. Connections are defined as vehicles going from one stop to another without an intermediate halt. These connections are then ordered by departure time, fragmented into documents, and are then published over HTTP. Clients can use the semantics embedded in each fragment to solve their own queries. This, combined with the fact that each fragment is easily cacheable, make Linked Connections servers very scalable <span class="references">[<a href="#ref-10">10</a>]</span>.</p>

      <h3 id="partitioning-public-transit-networks">Partitioning Public Transit Networks</h3>

      <p>Researchers in the field of route planning have noted that while methods based on partitioning have been successful for accelerating queries on road networks, adapting those methods to public transit networks is harder than expected <span class="references">[<a href="#ref-11">11</a>, <a href="#ref-12">12</a>]</span>. One of the main differences is that road networks are, for the most part, topological networks. Public transit networks on the other hand are also inherently time-dependent, while road networks. On top of that, it is not even clear <em>what</em> exactly needs to be partitioned as different algorithms can require wildly different data models <span class="references">[<a href="#ref-13">13</a>]</span>.</p>

      <p>The Scalable Transfer Patterns <span class="references">[<a href="#ref-14">14</a>]</span> algorithm that aims to greatly reduce preprocessing times of the original Transfer Patterns <span class="references">[<a href="#ref-15">15</a>]</span> algorithm. The authors compared 4 different techniques to partition stops into clusters of roughly equal size: 1) k-Means using the stops’ geographical locations, 2) a merge-based clustering with a utility function that punishes big partitions and rewards pairs of partitions with high edge weights between them , 3) a general-purpose graph clustering algorithm called METIS <span class="references">[<a href="#ref-16">16</a>]</span>, and 4) a road partitioning method called PUNCH <span class="references">[<a href="#ref-17">17</a>]</span>. They found that k-Means, despite being completely oblivious to the network structure outperformed, outperformed both METIS and PUNCH while the merge-based approach performed the best of all. HypRAPTOR <span class="references">[<a href="#ref-13">13</a>]</span> is another route planning algorithm that uses METIS to partition the network graph, but it clusters trips instead of stops.</p>

      <h3 id="voronoi-diagrams">Voronoi Diagrams</h3>

      <p>Voronoi diagrams are one of the most fundamental data structures in computational geometry <span class="references">[<a href="#ref-18">18</a>]</span>. Although they can be applied to any metric space, we only consider Euclidean spaces in this paper for the sake of simplicity. Given a set of seed points in a Euclidean space, a Voronoi diagram partitions that space into regions so that each region contains exactly one seed point, and every point in a region is closer to that region’s seed point than to any other region’s. Formally this means that for a given Euclidean space <script type="math/tex">X</script> with distance function <script type="math/tex">d</script>, and a set of seed points <script type="math/tex">P \subset X</script>, each point <script type="math/tex">p_i \in P</script> yields a corresponding Voronoi region <script type="math/tex">R_i \subseteq X</script> where</p>

      <script type="math/tex; mode=display">R_i = \{ x \in X \mid d(x, p_i) \leq d(x, p_j) \text{ for all } i \neq j  \}</script>

    </div>
</section>

  <section id="method" inlist="" rel="schema:hasPart" resource="#method">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Method</h2>

      <figure style="display:flex; flex-wrap:wrap" id="frequencies">
    <img src="./img/query_frequencies.png" width="399px" style="min-width: 50%; flex:1; border: none; box-shadow: none;" />
	<img src="./img/connection_frequencies.png" width="399px" style="min-width: 50%; flex:1; border: none; box-shadow: none;" />
    <figcaption><span class="label">Fig. 1:</span> 
   Visualized on the left are the departure and destination locations based on one week of query logs from the Flemish public transit operator De Lijn. Visualized on the right are the locations of all connections during the same time period. Note that there are many places with a considerable amount of connections that are in low demand. 
    </figcaption>
</figure>

      <p>The Linked Connections publishing scheme already a good job at enabling applications to ingest the most relevant data, but each fragment still contains data from the entire transit operator’s service area. <a href="#frequencies">Fig. 1</a> shows that some regions served by the Flemish public transit operator, De Lijn, are more popular than others, implying that it makes sense to fragment by location.</p>

      <p>However, first we should consider what is necessary to make publishing fragmented data viable in the real world. We make a distinction between data owners and data publishers, with a clear distinction between their responsibilities. A data owner focuses on maintaining the data quality, while a data publisher focuses on making the data accessible. Both roles come with their own challenges, and as such it is not uncommon for data owners to consult third parties to publish the data for them. This means that data publishers may not have control over the actual data – when the data changes they just have to follow. For example, public transit operators routinely add and remove temporary stops due to maintenance works, and these changes have to be reflected in the published data with as little friction as possible.</p>

      <h3 id="data">Data</h3>

      <p>Lead by the insights provided by <a href="#frequencies">Fig. 1</a>, we will focus on Flemish public transit network for the remainder of this paper.  Flanders is a small region within Europe, but with 487 inhabitans/km² in 2019 it is also one of the most densely populated <span class="references">[<a href="#ref-19">19</a>]</span>. The public transit network is equally dense; at the time of writing there are 35,791 stops spread out over 13,522 km² for a stops density of 2.6 stops/km². There are roughly 1 billion connections on a regular weekday, and the corresponding Linked Connections data results in over 10 billion RDF triples per day.  We use one data from the first whole week of December as the base data in the rest of this section.</p>

      <h3 id="clustering">Clustering</h3>

      <p>Existing work has focused on clustering stops, or trips, into discrete sets of objects. This means that any time a new stop gets added by the data owner, the data publisher must explicitly label the new stop as well. For clustering algorithms such as k-Means this is relatively easy, but for algorithms such as METIS this means recomputing the entire clustering. Instead of coming up with another clustering algorithms that is easy to update, we propose to publish the clusters differently. Instead of creating discrete sets of stops, we partition the physical world. The resulting partitions are published as separate resources, allowing any agent to infer to which cluster every stop belongs. In other words, data publishers do not have to explicitly label every stop themselves – the data speaks for itself.</p>

      <figure style="display:flex; flex-wrap:wrap" id="clusterings">
	<img src="./img/kmeans_8.svg" width="399px" style="min-width: 50%; flex:1; border: none; box-shadow: none;" />
    <img src="./img/metis_8.svg" width="399px" style="min-width: 50%; flex:1; border: none; box-shadow: none;" />
    <br />
    <img src="./img/prio_8.svg" width="399px" style="min-width: 50%; flex:1; border: none; box-shadow: none;" />
	<img src="./img/merged_8.svg" width="399px" style="min-width: 50%; flex:1; border: none; box-shadow: none;" />
    <figcaption><span class="label">Fig. 2:</span> The 8 partitions each of the 4 evaluated approaches create. Note that the two methods on the top row create regions of roughly equal sizes, while the approaches at the bottom create regions of varying sizes. The approaches in the left column create regions with simple shapes, while the ones on the right create irregular shapes.</figcaption>
</figure>

      <h4 id="k-means">k-Means</h4>

      <p>Although k-Means is a simple algorithm, existing work has found it to be competitive with more complex methods <span class="references">[<a href="#ref-14">14</a>]</span>, so we consider it among the state of the art for this particular use-case. As the name implies, this clustering distributes a given set of points in exactly <script type="math/tex">k</script> clusters, where every point belongs to cluster with the nearest cluster mean. Iterative heuristics exist to compute this clustering, we used the implementation from <a href="https://scikit-learn.org/0.20/modules/clustering.html#k-means">scikit.learn 0.20.3</a> with default parameters, and using the stops’ WGS84 coordinates as input. To obtain to wanted spatial partitioning we create a Voronoi diagram using the cluster means as seed points. Because the Voronoi cells of two adjacent points on the convex hull share an infinitely long edge, we add some extra padding points that represent the bounding box of the operator’s service area – and then discard all infinite edges.</p>

      <h4 id="metis">METIS</h4>

      <p>METIS is another algorithm that is used to partition public transit networks <span class="references">[<a href="#ref-13">13</a>, <a href="#ref-14">14</a>]</span>, so we consider it to be the state of the art as well. Since it is a graph clustering algorithm, we must represent the public transit network as a graph. We follow the conventional approach of creating a vertex for every stop, and connecting them with an edge if they are connected through a single connection. Every edge is assigned a weight that corresponds to how many connections connect those stops. We used <a href="https://metis.readthedocs.io/en/latest/">Python wrapper</a> to compute the clustering, using the <code>contig</code> option to force contiguous partitions.</p>

      <p>The METIS algorith only sees the network as a connectivity graph though – it does not know anything about the physical location of the stops. This means that even though it creates contiguous partitions, those partitions aren’t contiguous in the physical world. We obtain a clean spatial partitioning using an additional post-processing step that 1) creates the Voronoi diagram of all stops, 2) merges all Voronoi cells that belong to the same cluster, and 3) merge isolated rings into the encompassing cluster.</p>

      <h4 id="prio">Prio</h4>

      <p>Both k-Means and METIS are general purpose clustering techniques, and both ignore an important feature of the data: k-Means does not consider network connectivity and METIS does not consider physical locations. Although the main goal of this paper is not to find a better clustering technique, we were curious how a simple domain-specific approach compares to traditional methods.</p>

      <p>The algorithm iteratively selects the stops based on which trips pass through it. In the first iteration it selects the stop with the most unique trips, in the subsequent iterations it selects the stop with the most unique trips that the previous stop(s) did not have. As there is a finite amount of trips, this algorithm has a clear termination condition: when all trips are covered by one of the selected stops. After <script type="math/tex">k</script> iterations it contains the $k$ most important hubs, which lead us to name this method <em>prio</em>. These selected stops are then used as seed points to create a Voronoi diagram. <a href="#prio">Fig. 3</a> contains all the necessary code to implement this, up until the creation of the Voronoi diagram.</p>

      <figure id="prio">
<pre style="color:#000000;overflow-x: hidden"><code>def prio<span style="color:#808030; ">(</span>k<span style="color:#808030; ">)</span><span style="color:#800080; ">:</span>
    done_trips <span style="color:#808030; ">=</span> set<span style="color:#808030; ">(</span><span style="color:#808030; ">)</span>
    selected_stops <span style="color:#808030; ">=</span> <span style="color:#808030; ">[</span><span style="color:#808030; ">]</span>
    <span style="color:#800000; font-weight:bold; ">for</span> _ in range<span style="color:#808030; ">(</span>k<span style="color:#808030; ">)</span><span style="color:#800080; ">:</span>
        best_stop <span style="color:#808030; ">=</span> None
        best_stop_score <span style="color:#808030; ">=</span> <span style="color:#008c00; ">0</span>
        <span style="color:#800000; font-weight:bold; ">for</span> stop<span style="color:#808030; ">,</span> trips in stop_to_trips<span style="color:#808030; ">.</span>items<span style="color:#808030; ">(</span><span style="color:#808030; ">)</span><span style="color:#800080; ">:</span>
            stop_score <span style="color:#808030; ">=</span> len<span style="color:#808030; ">(</span>set<span style="color:#808030; ">(</span>trips<span style="color:#808030; ">)</span> <span style="color:#808030; ">-</span> set<span style="color:#808030; ">(</span>done_trips<span style="color:#808030; ">)</span><span style="color:#808030; ">)</span>
            <span style="color:#800000; font-weight:bold; ">if</span> stop_score <span style="color:#808030; ">&gt;</span> best_stop_score<span style="color:#800080; ">:</span>
                best_stop <span style="color:#808030; ">=</span> stop
                best_stop_score <span style="color:#808030; ">=</span> stop_score
        selected_stops<span style="color:#808030; ">.</span>append<span style="color:#808030; ">(</span>best_stop<span style="color:#808030; ">)</span>
        done_trips<span style="color:#808030; ">.</span>update<span style="color:#808030; ">(</span>stop_to_trips<span style="color:#808030; ">[</span>best_stop<span style="color:#808030; ">]</span><span style="color:#808030; ">)</span>
    <span style="color:#800000; font-weight:bold; ">return</span> selected_stops</code>
</pre>
<figcaption><span class="label">Fig. 3:</span> 
  The <em>prio</em> method can be implemented in just 14 lines of Python code.
</figcaption>
</figure>

      <h4 id="merged">Merged</h4>

      <p>Instead of stopping the previous algorithm after <script type="math/tex">k</script> iterations we can also let it terminate, and then use the Jaccard similarity coefficient to merge the two most similar adjacent Voronoi regions until only <script type="math/tex">k</script> remain. This makes the process more complex, but existing work has shown good results using hierarchical clustering techniques <span class="references">[<a href="#ref-14">14</a>]</span>.</p>

      <h3 id="hypermedia-controls">Hypermedia Controls</h3>

      <p>The obtained Voronoi regions are published to the web as stand-alone resources using the Hydra and GeoSPARQL vocabularies. The Hydra in this case is used to describe a partitioning as a collection of regions, and the <code>wktLiteral</code> datatype from the GeoSPARQL vocabulary is used to describe individual regions. GeoJSON is another common way to define geometries, but since GeoJSON polygons are incompatible with JSON-LD we chose to use a simple string representation: WKT. <a href="#partitionresource">Fig. 4</a> contains a JSON-LD snippet of a single partition resource.</p>

      <figure id="partitionresource">
<pre style="color:#000000; overflow-x: hidden;"><code><span style="color:#696969; ">{</span>
<span style="color:#696969; ">&nbsp;&nbsp;"@id": "</span><span style="color:#5555dd; ">https:/​/​example.org/shapes/prio_4</span><span style="color:#696969; ">",</span>
<span style="color:#696969; ">&nbsp;&nbsp;"hydra:member": [</span>
<span style="color:#696969; ">&nbsp;&nbsp;&nbsp;&nbsp;{</span>
<span style="color:#696969; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"@id": "</span><span style="color:#5555dd; ">https:/​/​example.org/shapes/prio_4/1</span><span style="color:#696969; ">",</span>
<span style="color:#696969; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"geo:asWKT": "POLYGON ((4.170761972221639 50.70794391488566, 5.611060049825466 51.96704409851701, 4.233768984483664 54.50221456451739, 3.77479828593018 53.53143994233906, 3.799815048180065 52.18573049093929, 4.170761972221639 50.70794391488566))"</span>
<span style="color:#696969; ">&nbsp;&nbsp;&nbsp;&nbsp;}</span><span style="color:#808030; ">,</span> <span style="color:#808030; ">..</span><span style="color:#808030; ">.</span>
  <span style="color:#808030; ">]</span><span style="color:#808030; ">,</span> <span style="color:#808030; ">..</span><span style="color:#808030; ">.</span>
}</code>
</pre>
<figcaption><span class="label">Fig. 4:</span> 
  JSON-LD representation of a partitioning. Note that both the partitioning as the individual regions are separate resources, which allows other datasets to refer to them.
</figcaption>
</figure>

      <p>These partition resources are then be used to fragment Linked Connections data. This separation allows for reusing existing partitions, such as administrative regions. A modified Linked Connections server can ingest a given partitioning, and fragment the data accordingly. The server creates one <code>hydra:PartialCollectionView</code> instance per region, and then creates an index of all generated views using the <a href="https://github.com/pietercolpaert/TreeOntology"><code>tree</code></a> ontology. This ontology is used to link every view to the resource that describes a geospatial area. <a href="#partioncontrols">Fig. 5</a> contains a JSON-LD snippet of such an index.</p>

      <figure id="partioncontrols">
<pre style="color:#000000; overflow-x: hidden; background: #f5f5f5;"><code><span style="color:#696969; ">{</span>
<span style="color:#696969; ">&nbsp;&nbsp;"@id": "</span><span style="color:#5555dd; ">http:/​/​example.org/connections</span><span style="color:#696969; ">",</span>
<span style="color:#696969; ">&nbsp;&nbsp;"@type": "tree:Node",</span>
<span style="color:#696969; ">&nbsp;&nbsp;"tree:relation": [</span>
<span style="color:#696969; ">&nbsp;&nbsp;&nbsp;&nbsp;{</span>
<span style="color:#696969; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"@type": "tree:GeospatiallyContainsRelation",</span>
<span style="color:#696969; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"shacl:path": "geo:contains",</span>
<span style="color:#696969; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"tree:node": "</span><span style="color:#5555dd; ">http:/​/​example.org/connections?cluster=https%3A//example.org/shapes/prio_4/1</span><span style="color:#696969; ">",</span>
<span style="color:#696969; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"tree:value": {</span>
<span style="color:#696969; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"@id": "</span><span style="color:#5555dd; ">https:/​/​example.org/shapes/prio_4/1</span><span style="color:#696969; ">",</span>
<span style="color:#696969; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"geo:asWKT": "POLYGON ((4.170761972221639 50.70794391488566, 5.611060049825466 51.96704409851701, 4.233768984483664 54.50221456451739, 3.77479828593018 53.53143994233906, 3.799815048180065 52.18573049093929, 4.170761972221639 50.70794391488566))",</span>
<span style="color:#696969; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"@type": "geo:Geometry"</span>
<span style="color:#696969; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span>
    }<span style="color:#808030; ">,</span> <span style="color:#808030; ">..</span><span style="color:#808030; ">.</span>
  <span style="color:#808030; ">]</span><span style="color:#808030; ">,</span> <span style="color:#808030; ">..</span><span style="color:#808030; ">.</span>
}</code>
</pre>
<figcaption><span class="label">Fig. 5:</span> 
  JSON-LD representation of a view index. The <code>tree:node</code> property points to a <code>hydra:PartialCollectionView</code>, which is a connections page from original Linked Connections specification. The <code>tree:value</code> property defines which geospatial area that view covers.
</figcaption>
</figure>
    </div>
</section>

  <section id="evaluation" inlist="" rel="schema:hasPart" resource="#evaluation">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Evaluation</h2>

      <p>We have adapted an existing library for client-side route planning so that it can interpret our hypermedia controls, and decide which data to download. This library uses the earliest arrival time variant of the Connection Scan Algorithm. This algorithm, similar to Dijkstra’s algorithm, builds a list of which stops are reachable and how long it takes to reach them. A client that knows the location of each stop can also infer which clusters are reachable, so our adapted route planner simply fetches data for all reachable clusters – slowly growing its list of data sources. We focus on the use-case of client-side route planning because this a relatively demanding application.</p>

      <p>As mentioned in <a href="#method">Section 3</a>, we use 1 week of Linked Connection as input to train the clustering algorithms. We then used each method to create 4, 8, 16, and 32 clusters. A redis-backed server then creates an ordered list of all connections within every generated region, and exposes these using the hypermedia controls defined in the <a href="#hypermedia-controls">Subsection 3.3</a>. The same server also hosts a version of the data with one cluster that contains all the data, i.e. without any geospatial partitioning. Altogether we test 17 different partitionings, each data fragment contains 20 minutes of data.</p>

      <p>We make extensive use of letter-value plots <span class="references">[<a href="#ref-20">20</a>]</span> as our results have a long tail, causing conventional visualizations such as box plots to label many results as outliers. These plots show the median value as a black line, and then show the 75%, 87.5%, … percentile as separate boxes, making it easy to compare these statistics.</p>

      <h3 id="usability">Usability</h3>

      <p>As a proxy for how <em>useful</em> the geospatially fragmented data is for an end-user, we measure how much work the client has to do to come to the same result. Specifically, how long it takes for the same client to come to an answer with a given partitioning, as well as how much data was downloaded, and compare those values to those of the baseline – the unpartitioned data.</p>

      <p>5,000 queries were randomly selected from a query log that was given to by the transit the operator itself. All these queries occurred on the same day, but throughout the day.  We eliminate as many variables as possible to isolate the impact of the partitioning; the client and server run on two separate machines on the same local network, a constant 20 ms of latency is added per response, and the client only processes one query at a time.</p>

      <figure id="elapsed">
    <img src="./img/elapsed_boxen.svg" width="100%" />
    <figcaption><span class="label">Fig. 6:</span> The median query time with just 4 clusters is already 58% that of the original query times, and using 8 clusters further improves this to 45%. Note the diminishing returns as more clusters are added though, using 16 and 32 clusters lower the relative query times to 41% and 42%. The prio and k-Means methods yield very similar results, while METIS performs significantly worse.</figcaption>
</figure>

      <figure id="downloaded">
    <img src="./img/downloaded_boxen.svg" width="100%" />
    <figcaption><span class="label">Fig. 7:</span> Using just 4 clusters is enough to reduce the amount of downloaded data to 45% of the original amount of downloaded data, and adding more clusters consistently improves this metric. Although all methods seem competitive in this metric, the prio method has a consistently low median and 75% percentile.</figcaption>
</figure>

      <p><a href="#elapsed">Fig. 6</a> shows that having just a few clusters already significantly improves the query performance, but that adding more clusters has diminishing returns. Even without the overhead of ingesting unnecessary data the client still has to compute the route. The METIS results are somewhat surprising; they are slightly worse across the board, and even become worse when going from 16 to 32 clusters. As <a href="#clusterings">Fig. 2</a> shows, the clusters from METIS are more complex than those from other methods, which creates a heavier workload on the client. <a href="#downloaded">Fig. 7</a> shows that the amount of downloaded data does keep decreasing by adding more clusters, we can even avoid all unnecessary data by creating a cluster per stop.</p>

      <h3 id="cacheability">Cacheability</h3>

      <p>Another important feature of Linked Connections is the cacheability of the data fragments, which gives a Linked Connections server its scalability. Because we are making the data more fine-grained, we have to measure the impact this has on the cacheability of the data. Unfortunately, we do not have access to any form of user ID, which makes it hard to benchmark a real world scenario where there are client-side and server-side caches. Instead, we measure how fast a cache warms up in every configuration, and what the hit rate of a warm cache is. These two metrics give an indication of how cacheable the partitioned data is, and how this compares to the cacheability of the original data.</p>

      <p>While running the benchmarks for the usability metrics, we also record which resources are fetched. We then replay these requests, running them through a simulated LRU cache to measure the hit rates. Every partition results in roughly 70 MB of gzipped data per day, and we set the cache size to 20 MB. To measure the hit rates on a warm cache we first run all requests through a cache, and then create 1,000 samples of 500 requests to measure the overall hit rate of each sample. The hit rates on a cold cache are obtained by doing the same starting from a cold cache, and by varying the amount of requests per sample.</p>

      <figure id="warm">
    <img src="./img/warm_cache.svg" width="100%" />
    <figcaption><span class="label">Fig. 8:</span> Less valuable cache space is wasted on irrelevant data by using a fine-grained partitioning. The median hit rate on a warm cache using the unpartitioned data is 26%, the highest hit rate, 44%, is obtained using the prio method at 32 clusters. The k-Means method scores noticeable worse than the other methods.</figcaption>
</figure>

      <figure id="cold">
    <img src="./img/cold_cache.svg" width="100%" />
    <figcaption><span class="label">Fig. 9:</span> Line plots of the median cache hit rates per configuration, showing that caches take longer to warm with a fine-grained partitioning. However, each method with 4 or 8 clusters matches the hit rate of the original data on a warm cache (26%) after 350 requests.</figcaption>
</figure>

      <p><a href="#warm">Fig. 8</a> and <a href="#cold">Fig. 9</a> show that partitioned data can improve the cache hit rate, but that caches take longer to warm up. All methods are competitive with each other at 4 and 8 clusters, but k-Means is outperformed by the other three at 16 and 32 clusters. Although using 8 instead of 4 clusters yields better hit rates on a warm cache, both configurations surpass the baseline warm cache hit rate of 26% after roughly 350 requests.</p>
    </div>
</section>

  <section id="discussion" inlist="" rel="schema:hasPart" resource="#discussion">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Discussion</h2>

      <p>Our findings shows that results from the field of route planning do not necessarily translate to publishing data on the web. When publishing processed data on the web, we need to keep the processed data to stay in sync with the raw data. We solve this problem by moving some of the clustering logic to the client, which can avoid downloading and parsing a lot of irrelevant data in return. Even a small amount of clusters can make a client-side route planner twice as fast.</p>

      <p>The number of clusters has a noticeable impact on all evaluated metrics. More clusters do not necessarily lead to better results, as we quickly see diminishing returns in terms of query times. The amount of downloaded data does keep decreasing, but at the cost of cacheability. Interestingly, even when starting from a cold cache the cacheability of a small amount of clusters is on par with the cacheability of the original data. Although it takes longer to warm up, the hit rate of a warm cache is higher for fine-grained data.</p>

      <p>METIS and k-Means yield good results in the amount of downloaded data metric, but both struggle in other tests. Clusters from METIS have a complex shape because it does not consider the stops’ locations, making it harder for clients to interpret them. As a result, the query times using METIS data are consistently worse than those using other methods. A similar pattern presents itself for the merge-based method, which is also noticeable worse in the query time metric – more so than in the downloaded data metric. The k-Means method on the other hand shows great results in both the query time and downloaded data metrics, but the resulting data fragments are harder to cache.</p>

      <p>The prio method is the only method that performs well across all metrics. This method combines the geospatial and the graph-like features of public transit networks, unlike both k-Means and METIS. The merge-based approach does this all well, but is burdened by more complex cluster shapes. More than anything, partitioning and publishing public transit schedules seems to be an exercise in moderation: don’t use too many clusters, and stick to simple shapes.</p>
    </div>
</section>

  <section id="conclusion" inlist="" rel="schema:hasPart" resource="#conclusion">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Conclusion</h2>

      <p>The paper introduced hypermedia controls to describe geospatial partitions, which clients can use to discover clusters of public transit stops. We evaluated 4 different clustering methods for the use-case of client-side route planning: k-Means, METIS, and two domain-specific methods of our own. Despite being very popular in the field of route planning, METIS has subpar results compared to the other methods. The complex nature of METIS clusters make them hard to interpret for clients. The other ubiquitous method, k-Means, does lead to good query times, but is harder to cache – which is an important feature for publishing open data in a scalable fashion. The most promising method, both in terms of user convenience and cacheability, is to just create a Voronoi diagram around the most important transportation hubs. Although simple, this method results in simple clusters, while still incorporating both the geospatial and graph-like nature of transit data. The same less-is-more pattern repeats itself when looking at the role of the number of clusters; adding more clusters has diminishing returns on the query time, while making the data harder to cache.</p>

      <p>Our goal was to make open transit data more useful, so that more people can enjoy it in more applications. And in that regard, we succeeded. A small amount of clusters, 4 or 8, and a simple clustering algorithm is all it takes to make client-side route planners more than twice as efficient. Preliminary results show that the cacheability, and thus the scalability, of this approach is on par with the existing Linked Connections publishing scheme. Future work can verify this scalability in the real world, and compare it to both route planning services and existing Linked Connections servers. On top of that, more work can be done into finding good clustering strategies, because what works well for integrated services does not appear to work well for publishing data.</p>
    </div>
</section>


  <script src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/mathtex-script-type.min.js" integrity="sha384-LJ2FmexL77rmGm6SIpxq7y+XA6bkLzGZEgCywzKOZG/ws4va9fUVu2neMjvc3zdv" crossorigin="anonymous"></script>
</main>

<footer><section>
<h2 id="references">References</h2>
<dl class="references">
  <dt id="ref-1">[1]</dt>
  <dd resource="https://dx.doi.org/https://doi.org/https://doi.org/10.1787/5k46bj4f03s7-en" typeof="schema:Article">Ubaldi, B.: Open Government Data. (2013).</dd>
  <dt id="ref-2">[2]</dt>
  <dd resource="#fair" typeof="schema:Article">Wilkinson, M.D., Dumontier, M., Aalbersberg, I.J.J., Appleton, G., Axton, M., Baak, A., Blomberg, N., Boiten, J.-W., da Silva Santos, L.B., Bourne, P.E., others: The FAIR Guiding Principles for scientific data management and stewardship. Scientific data. 3, (2016).</dd>
  <dt id="ref-3">[3]</dt>
  <dd resource="#landi2019fair" typeof="schema:Article">Landi, A., Thompson, M., Giannuzzi, V., Bonifazi, F., Labastida, I., da Silva Santos, L.O.B., Roos, M.: The “A” of FAIR–as open as possible, as closed as necessary. Data Intelligence. 47–55 (2019).</dd>
  <dt id="ref-4">[4]</dt>
  <dd resource="#googlemaps" typeof="schema:Article">Bast, H., Carlsson, E., Eigenwillig, A., Geisberger, R., Harrelson, C., Raychev, V., Viger, F.: Fast routing in very large public transportation networks using transfer patterns. In: European Symposium on Algorithms. pp. 290–301. Springer (2010).</dd>
  <dt id="ref-5">[5]</dt>
  <dd resource="#ch" typeof="schema:Article">Geisberger, R., Sanders, P., Schultes, D., Delling, D.: Contraction hierarchies: Faster and simpler hierarchical routing in road networks. In: International Workshop on Experimental and Efficient Algorithms. pp. 319–333. Springer (2008).</dd>
  <dt id="ref-6">[6]</dt>
  <dd resource="#csa" typeof="schema:CreativeWork">Dibbelt, J., Pajor, T., Strasser, B., Wagner, D.: Connection Scan Algorithm (2017).</dd>
  <dt id="ref-7">[7]</dt>
  <dd resource="#berners2006linked" typeof="schema:Article">Berners-Lee, T.: Linked data-design issues. <a href="http://www.w3.org/DesignIssues/LinkedData.html">http:/​/​www.w3.org/DesignIssues/LinkedData.html</a>. (2006).</dd>
  <dt id="ref-8">[8]</dt>
  <dd resource="#verborgh2014querying" typeof="schema:Article">Verborgh, R., Hartig, O., De Meester, B., Haesendonck, G., De Vocht, L., Vander Sande, M., Cyganiak, R., Colpaert, P., Mannens, E., Van de Walle, R.: Querying datasets on the web with high availability. In: International Semantic Web Conference. pp. 180–196. Springer (2014).</dd>
  <dt id="ref-9">[9]</dt>
  <dd resource="#antrim2013many" typeof="schema:Article">Antrim, A., Barbeau, S.J., others: The many uses of GTFS data–opening the door to transit and multimodal applications. Location-Aware Information Systems Laboratory at the University of South Florida. 4, (2013).</dd>
  <dt id="ref-10">[10]</dt>
  <dd resource="#colpaert2015intermodal" typeof="schema:Article">Colpaert, P., Llaves, A., Verborgh, R., Corcho, O., Mannens, E., Van de Walle, R.: Intermodal public transit routing using Liked Connections. In: International Semantic Web Conference: Posters and Demos. pp. 1–5 (2015).</dd>
  <dt id="ref-11">[11]</dt>
  <dd resource="#berger2009accelerating" typeof="schema:Article">Berger, A., Delling, D., Gebhardt, A., Müller-Hannemann, M.: Accelerating time-dependent multi-criteria timetable information is harder than expected. In: 9th Workshop on Algorithmic Approaches for Transportation Modeling, Optimization, and Systems (ATMOS’09). Schloss Dagstuhl-Leibniz-Zentrum für Informatik (2009).</dd>
  <dt id="ref-12">[12]</dt>
  <dd resource="#bauer2011experimental" typeof="schema:Article">Bauer, R., Delling, D., Wagner, D.: Experimental study of speed up techniques for timetable information systems. Networks. 57, 38–52 (2011).</dd>
  <dt id="ref-13">[13]</dt>
  <dd resource="#delling2017faster" typeof="schema:Article">Delling, D., Dibbelt, J., Pajor, T., Zündorf, T.: Faster transit routing by hyper partitioning. In: 17th Workshop on Algorithmic Approaches for Transportation Modelling, Optimization, and Systems (ATMOS 2017). Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik (2017).</dd>
  <dt id="ref-14">[14]</dt>
  <dd resource="#bast2016scalable" typeof="schema:Article">Bast, H., Hertel, M., Storandt, S.: Scalable transfer patterns. In: 2016 Proceedings of the Eighteenth Workshop on Algorithm Engineering and Experiments (ALENEX). pp. 15–29. SIAM (2016).</dd>
  <dt id="ref-15">[15]</dt>
  <dd resource="#bast2010fast" typeof="schema:Article">Bast, H., Carlsson, E., Eigenwillig, A., Geisberger, R., Harrelson, C., Raychev, V., Viger, F.: Fast routing in very large public transportation networks using transfer patterns. In: European Symposium on Algorithms. pp. 290–301. Springer (2010).</dd>
  <dt id="ref-16">[16]</dt>
  <dd resource="#karypis1998fast" typeof="schema:Article">Karypis, G., Kumar, V.: A fast and high quality multilevel scheme for partitioning irregular graphs. SIAM Journal on scientific Computing. 20, 359–392 (1998).</dd>
  <dt id="ref-17">[17]</dt>
  <dd resource="#delling2011graph" typeof="schema:Article">Delling, D., Goldberg, A.V., Razenshteyn, I., Werneck, R.F.: Graph partitioning with natural cuts. In: 2011 IEEE International Parallel &amp; Distributed Processing Symposium. pp. 1135–1146. IEEE (2011).</dd>
  <dt id="ref-18">[18]</dt>
  <dd resource="#aurenhammer1991voronoi" typeof="schema:Article">Aurenhammer, F.: Voronoi diagrams—a survey of a fundamental geometric data structure. ACM Computing Surveys (CSUR). 23, 345–405 (1991).</dd>
  <dt id="ref-19">[19]</dt>
  <dd resource="#vlaanderen" typeof="schema:Article">Flanders: Population: size and growth. <a href="https://www.statistiekvlaanderen.be/en/population-size-and-growth-0">https:/​/​www.statistiekvlaanderen.be/en/population-size-and-growth-0</a>. (2019).</dd>
  <dt id="ref-20">[20]</dt>
  <dd resource="#letter-value-plot" typeof="schema:CreativeWork">Hofmann, H., Kafadar, K., Wickham, H.: Letter-value plots: Boxplots for large data. had.co.nz (2011).</dd>
</dl>
</section>
</footer>


</body>
</html>
